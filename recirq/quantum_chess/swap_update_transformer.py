# Copyright 2021 Google
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Implementation of the swap update algorithm described in the paper 'A Dynamic
Look-Ahead Heuristic for the Qubit Mapping Problem of NISQ Computers'
(https://ieeexplore.ieee.org/abstract/document/8976109).

This transforms circuits by adding additional SWAP gates to ensure that all operations are on adjacent qubits.
"""
from collections import defaultdict
from typing import Callable, Dict, Generator, Iterable, List, Optional, Tuple

import cirq

import recirq.quantum_chess.circuit_transformer as ct
import recirq.quantum_chess.mcpe_utils as mcpe

ADJACENCY = [(0, 1), (0, -1), (1, 0), (-1, 0)]


def _satisfies_adjacency(gate: cirq.Operation) -> bool:
    """Returns true iff the input gate operates on adjacent qubits.

    Requires the input to be either a binary or unary operation on GridQubits.
    """
    assert len(gate.qubits) <= 2
    if len(gate.qubits) < 2:
        return True
    q1, q2 = gate.qubits
    return q1.is_adjacent(q2)


def generate_swap(q1: cirq.Qid,
                  q2: cirq.Qid) -> Generator[cirq.Operation, None, None]:
    """Generates a single SWAP gate."""
    yield cirq.SWAP(q1, q2)


def generate_iswap(q1: cirq.Qid,
                   q2: cirq.Qid) -> Generator[cirq.Operation, None, None]:
    """Generates an ISWAP as two sqrt-ISWAP gates.

    This is a suitable replacement for SWAPs (up to a phase shift) but is a more
    efficient representation on hardware supporting sqrt-ISWAP natively (ex
    Google Sycamore chips).
    """
    yield cirq.ISWAP(q1, q2)**0.5
    yield cirq.ISWAP(q1, q2)**0.5


class SwapUpdater:
    """SwapUpdater runs the swap update algorithm in order to incrementally update a circuit with SWAPs.

    The SwapUpdater's internal state is modified as the algorithm runs, so each instance is one-time use.

    Args:
      circuit: the circuit to be updated with additional SWAPs
      device_qubits: the allowed set of qubits on the device. If None, behaves
        as though operating on an unconstrained infinite device.
      initial_mapping: the initial logical-to-physical qubit mapping, which
        must contain an entry for every qubit in the circuit
      swap_factory: the factory used to produce operations representing a swap
        of two qubits
    """
    def __init__(self,
                 circuit: cirq.Circuit,
                 device_qubits: Optional[Iterable[cirq.GridQubit]],
                 initial_mapping: Dict[cirq.Qid, cirq.GridQubit] = {},
                 swap_factory: Callable[[cirq.Qid, cirq.Qid],
                                        List[cirq.Operation]] = generate_swap):
        self.device_qubits = device_qubits
        self.dlists = mcpe.DependencyLists(circuit)
        self.mapping = mcpe.QubitMapping(initial_mapping)
        self.swap_factory = swap_factory

    def _adjacent_qubits(
            self,
            qubit: cirq.GridQubit) -> Generator[cirq.GridQubit, None, None]:
        """Generates the qubits adjacent to a given GridQubit on the device."""
        for diff in ADJACENCY:
            other = qubit + diff
            if self.device_qubits is None or other in self.device_qubits:
                yield other

    def generate_candidate_swaps(
        self, gates: Iterable[cirq.Operation]
    ) -> Generator[Tuple[cirq.GridQubit, cirq.GridQubit], None, None]:
        """Generates the candidate SWAPs that would have a positive effect on at
        least one of the given physical gates.

        Args:
          gates: the list of gates to consider which operate on GridQubits
        """
        for gate in gates:
            for gate_q in gate.qubits:
                yield from (
                    (gate_q, swap_q)
                    for swap_q in self._adjacent_qubits(gate_q)
                    if mcpe.effect_of_swap((gate_q, swap_q), gate.qubits) > 0)

    def update_iteration(self) -> Generator[cirq.Operation, None, None]:
        """Runs one iteration of the swap update algorithm and updates internal
        state about the original circuit.

        Returns:
          the operations on GridQubits in the final updated circuit generated by
          this iteration
        """
        # Handle the already-satisfied active gates.
        # Those can be immediately added into the final circuit.
        active_physical_gates = []
        for gate in self.dlists.active_gates():
            physical_gate = gate.transform_qubits(self.mapping.physical)
            if _satisfies_adjacency(physical_gate):
                # physical_gate is ready to be popped off the dependecy lists
                # and added to the final circuit.
                for q in gate.qubits:
                    self.dlists.pop_front(q)
                yield physical_gate
            else:
                # physical_gate needs to be fixed up with some swaps.
                active_physical_gates.append(physical_gate)

        # If all the active gates in this pass were added to the final circuit,
        # then we have nothing left to do until we make another pass and get the
        # newly active gates.
        if not active_physical_gates:
            return

        candidates = set(self.generate_candidate_swaps(active_physical_gates))
        # This could happen on irregular topologies or when some device
        # qubits are disallowed.
        assert candidates, 'no swaps found that will improve the circuit'
        chosen_swap = max(
            candidates,
            key=lambda swap: self.dlists.maximum_consecutive_positive_effect(
                *swap, self.mapping))
        self.mapping.swap_physical(*chosen_swap)
        yield from self.swap_factory(*chosen_swap)

    def add_swaps(self) -> Generator[cirq.Operation, None, None]:
        """Iterates the swap update algorithm to completion.

        If the updater already completed, does nothing.

        Returns:
          the generated operations on physical GridQubits in the final circuit
        """
        while not self.dlists.all_empty():
            yield from self.update_iteration()


class SwapUpdateTransformer(ct.CircuitTransformer):
    """Transformer that runs the SwapUpdater to transform circuits.

    Args:
      initial_mapping: the initial mapping between the circuit's logical qubits
        and physical GridQubits. This must contain all qubits in the circuit to
        be transformed.
    """
    def __init__(self, initial_mapping: Dict[cirq.Qid, cirq.GridQubit] = {}):
        super().__init__()
        self.initial_mapping = initial_mapping

    def transform(self, circuit: cirq.Circuit) -> cirq.Circuit:
        """Adds ISWAPs to satisfy adjacency constraints.

        Args:
          circuit: the input circuit of GridQubits to modify
        Returns:
          the modified circuit with ISWAPs inserted and operations mapped to
          physical GridQubits.
        """
        for q in circuit.all_qubits():
            assert q in initial_mapping
        updater = SwapUpdater(circuit, circuit.device.qubit_set(),
                              initial_mapping, generate_iswap)
        return cirq.Circuit(updater.add_swaps(), device=circuit.device)
